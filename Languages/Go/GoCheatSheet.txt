https://github.com/a8m/golang-cheat-sheet?tab=readme-ov-file#maps
https://quickref.me/go.html

DOES NOT SUPPORT:
    CLASSES
    INHERIRANCE

====================================================================================================

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++ KEYWORDS +++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Go Keywords can be categorized in 3 types:
    1. Declarative: used to declare different elements 
       - const, func, import, package, type and var
    2. Composite type denotations
       - chan, interface, map and struct
    3. Control flow
       - break, case, continue, default, else, fallthrough, for, goto, if, range, return, 
         select, switch, defer and go

    defer: halts the execution of a method unlesss the nearby methods are executed.
            - In other words, it adds the function preceding a defer to a stack and the execution
            of these methods start as LIFO once the method in which they were added returns.
            
            - it is used to produce the after effect of a method.
            Eg: cleaning up system resources, closing a file/channel/Network connection/db handles.
            
            - there can be multiple 'defer' statements within a method.
            
            Executed only when:
                - The surrounding function executed return statement.
                - The surrounding function reached the end of its execution.
                - The gorouting containing the defer keyword is panicking.

            Resources: 
                https://www.digitalocean.com/community/tutorials/understanding-defer-in-go
                https://go.dev/ref/spec#Defer_statements
                https://stackoverflow.com/questions/52718143/is-golang-defer-statement-execute-before-or-after-return-statement

    type: 

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++ DATA TYPES ++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    1. Basic types: Number, string & boolean
        1.1. Numbers: 
            1.1.1. Integers
                    Architecture independent types: 
                        int8 
                        int16 
                        int32 
                        int64 
                        uint8 
                        uint16 
                        uint32
                        uint64
                    Architecture dependent types: 
                        int:     signed, either 32 or 64 bits
                        uint:    unsigned, either 32 or 64 bits
                        uintptr: unsigned integer type. Its width is not defined, but it is large enough 
                                 to store the uninterpreted bits of a pointer value.
                    Alias Number Types:
                        rune: alias for int32. The difference is that ASCII characters can solely be
                                represented by int32 whereas rune is used to represent UNICODE characters.
                        byte: alias for uint8. Even though byte and uint8 are identical once the program 
                                is compiled, byte is often used to represent character data in numeric 
                                form, whereas uint8 is intended to be a number in your program.
            1.1.2. Floating Point
            1.1.3. Complex Numbers
        1.2. String 
        1.3. Boolean
                    
    2. Aggregate types: Array & struct
    3. Reference types: Pointers, slices, maps, functions & channels
    4. Interface types

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++ VARIABLE DECLARATIONS RULES ++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Declaration: var variable_name type = expression
    1. In the above syntax, either type or = expression can be omitted, but not both.
    2. If the type is removed, then the type of the variable is determined by the value-initialized in the expression.
    3. If the = expression is omitted, then the variable value is determined by its type’s default value.
       zero for the number, false for Booleans, “” for strings, and nil for interface and reference type
       --> Due to this, there is no such concept of an uninitialized variable in Go. <--

    4. When type is used, you are allowed to declare multiple variables of the same type in a single declaration.
    5. When type is removed, you are allowed to declare multiple variables of a different types in a single declaration. 
       The type of variables is determined by the initialized values
    6. You are allowed to initialize a set of variables by the calling function that returns multiple values.
       Eg: var file, error = os.Open(name)
    7. Short variable declaration: 
        The local variables which are declared and initialize in the functions are declared by using short variable declaration.
        --> variable_name:= expression
        Here, the type of the variable is determined by the type of the expression.

        Using short variable declaration you are allowed to declare multiple variables of different types in a single declaration.
        Ex: num, str, flt, bool := 30, "test", 10.23, false

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++ CONSTANTS +++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Once the value of constant is defined, it cannot be modified further.
Declaration: const var name = "abc" or const name = "abc"
    
    --> CONSTANTS CANNOT BE DECLARED USING SHORT VARIABLE DECLARATION

    Multiple constants can be declared at once using a block of brackets.
    Ex: const (
            GFG     = "GeeksforGeeks"
            Correct = true
            Pi      = 3.14
        )


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++ OPERATORS +++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
All operators are same as operators from other languages.

Misclaneous Operators in Go:
    1. &: Returns the address of a variable
    2. *: Returns a pointer to a variable
    3. <- : Also called receive operator, it receives a value from a channel

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++ TYPE CASTING: There is no type casting in go. Only type conversions. ++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++ TYPE CONVERSION +++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Syntax: var variable = (destination_type)(value)

It is important because Go does not allow the use of multiple types in an expression.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++ CONTROL STATEMENTS ++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
--> IF ELSE 
    if cond {

    } else { // else must be on the closing line of if 

    }

--> LOOPS 
    --> while loop: same as other languages
    --> for loop:
            1. Simple: for initialization; condition; post {}
            2. Infinite: for {}
            3. Over collections: for index, vlaue := range collection_name {}
            4. Over map: for key, value := range mp {}
            5. Over channels: for item := range channel {/* Loop continues until channel is closed. */}

--> Loop control statements: 
    --> break
    --> goto 
    --> continue

--> Switch Statement
    --> Expression Switch: Either of optionalStatement or optionalExpression is required
            switch optionalStatement; optionalExpression {
                case expression1:
                    //statements
                case expression2:
                    //statements
                ...
                default:
                    // default statement
            }
    
    --> Type Switch: used to branch on the type of an interface value, rather than its value. 
                     This is particularly useful when dealing with variables of unknown types.
            switch var := interfaceName.(type) {
                case type1:
                    //statement
                case type2:
                    //statement
                ...
                default:
                    //statement
            }


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++ SELECT: Used for channels and the case statements refers to communitation. +++++++++++++++ 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Helps avoid deadlock cases.

    Syntax: select {
                case x <- channel:
                    //statement
                default:
                    //default statement
            }

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++ FUNCTIONS  ++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Syntax: func func_name(params list)(return type) {}
    Supports "call by value" as well as "call by reference".

++++++++++++++++++++++
+ VARIADIC FUNCTIONS +
++++++++++++++++++++++
    1. Accepts unknown number of params.
    2. In the declaration of the variadic function, the type of the last parameter is preceded by 
       an ellipsis, i.e, (…). It indicates that the function can be called at any number of parameters
       of this type. 

    Syntax: function function_name(para1, para2...type)type {// code...}

+++++++++++++++++++++++
+ ANONYMOUS FUNCTIONS +
+++++++++++++++++++++++
    Functions with no name.
    Used to create inline functions or closures.

    Syntax: func(param list)(return_type) {//code} 

    Anonymous functions have following characteristics:
        1. can be assigned to a variable.
        2. can be passed to another function as argument.
        3. can be returned from another function.

+++++++++++++++++
+ MAIN FUNCTION +
+++++++++++++++++
    1. Entry point of the executable programs
    2. Neither takes any argument nor return anything.

+++++++++++++++++
+ INIT FUNCTION +
+++++++++++++++++
    1. Present in every package and this function is called when the package is initialized.
    2. It is declared implicitly, so you cannot reference it from anywhere.
    3. Multiple init() function can be created in the same program and they are executed in the order of creation.
    4. Can be created anywhere in the program.
    5. If there are multiple files with this method, then they are called in the lexical order 
       of their file name.
    6. Executed before the main function and does not depend on the main function.
    7. The main purpose of the init() function is to initialize the global variables that cannot 
       be initialized in the global context.

++++++++++++++++++++++++++++++++++++++++++
+ RETURN MULTIPLE VALUES FROM A FUNCTION +
++++++++++++++++++++++++++++++++++++++++++
    Syntax: func fun_name(param1, param2)(return_param1 type, return_param2 type2) {//code}
            
            Providing name to return types are optional and can be done as follows:
            
            func fun_name(param1 type, param2 type)(ret_val_1 type, ret_val_2 type) {
                ret_val_1 = param1
                ret_val_2 = param2

                return
            }

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++ *** METHODS *** +++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    - Go methods are similar to Go function with one difference,that the method contains a receiver 
      argument in it. With the help of the receiver argument, the method can access the properties 
      of the receiver. 
    - the receiver can be of struct type or non-struct type. 
    - the receiver and receiver type must be present in the same package the method resides in.
    - a method cannot be created with the receiver type defined in any other package, i.e; the 
      receiver type must be defined in the same package the method is defined in.

    syntax: fun(receiver_name type) method_name(params)(return_type) {//code}

    - a method can have struct/non-struct type receiver
    - *** used to create extension functions
    - methods with same name and different types can be defined

    Eg: Create a new method on int objects

        type new_int int //define the new integer type
        func(data new_int) multiply(d2 new_int) new_int {
            return data * d2
        }

        //call to above method
        func main() {
            d1, d2 := new_int(2), new_int(3)
            res := d1.multiply(d2)
            fmt.Println(res)
        }

 __________________________________________________________________________________________________
|            METHODS                            |                  FUNCTIONS                       |
----------------------------------------------------------------------------------------------------
|                                               |                                                  |
|- It contains a receiver.	                    | - It does not contain a receiver.                |
|- Methods of the same name but different types | - Functions of the same name but different type  |
|  can be defined in the program.	            |   are not allowed to be defined in the program.  |
|- It cannot be used as a first-order object.   | - It can be used as first-order objects and can  |
|                                               |   be passed                                      |

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ METHODS WITH SAME NAME: It is allowed to create two or more methods with the same name in the same +
+    package, but the receiver of these methods must be of different types.                          +
+                                                                                                    +
+  Example:                                                                                          +
+  func(reciver_name_1 Type) method_name(parameter_list)(return_type){ // Code }                     +
+  func(reciver_name_2 Type) method_name(parameter_list)(return_type){ // Code }                     +
+                                                                                                    +
+  NOTE: This feature is not available for functions. Meaning, you aren't allowed to create methods  + 
+  with same within the same package.                                                                +
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++ *** STRUCTURES *** ++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Structures: User defined type, used for composition, does not support inheritance

Declaration: "type" and "struct" keywords are used to define a structure.

Example: type Student struct {
            name string
            course string
            s_id int
         }

         1. var student Student                    
            student = Student{"raj", "cse", 1}

         2. Student := Student{"raj", "cse", 1}

++++++++++++++++++++++++++
+ Pointer to a structure +
++++++++++++++++++++++++++

    student := &Student{"raj", "cse", 1}
    fmt.Println("Name: ", (*student).name)

    NOTE: The pointer can also print the value without dereferencing as below.
    fmt.Println(student.name)

++++++++++++++++++++++
+ Structure Equality +
++++++++++++++++++++++
Comparison occurs based on structure types and their field values.

Comparison operator(==) and DeeplyEqual(): returns 
    true:  if the structures are identically equal(in terms of their fields values) to each other 
    false: if the structures are unequal(in terms of their fields values) to each other 
    error: if the structures are of different types.

usage:
    1. fmt.Println("Structures are equal: ", (s1 == s2))
    2. fmt.Println("Structures are equal: ", reflect.DeeplyEqual(s1, s2))

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++ Nested Structures: A structure is a field of another structure +++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++ ANONYMOUS STRUCTURES AND FIELDS ++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ANONYMOUS STRUCTURE: A structure without a name, useful to create one-time usable structures.

Syntax: variable_name := struct {
            //field
        }{
            //field values
        }
Example: 
        Element := struct { 
            name      string 
            branch    string 
            language  string 
            Particles int
        }{ 
            name:      "Pikachu", 
            branch:    "ECE", 
            language:  "C++", 
            Particles: 498, 
        } 
  
        // Display the anonymous structure 
        fmt.Println(Element)

ANONYMOUS FIELD: Fields whose name is not provided in the structue but it type is specified.
                 Such fields are accessed using the type name as the field name is not available.
Syntax: type TEST struct{
            int
            bool
            float64
        }

        test := Test{1, true, 12.3}
        fmt.Println(test.int, test.bool, test.float64)

NOTE: The structure can only have one field of a particular type, else it throws an errror.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++ PROMOTED FIELDS IN STRUCTURES  +++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Def: Just like anonymous fields, the type of the field is the name of the field. 
     It is used in nested structures.
     The fields of the nested structure are known as "PROMOTED FIELDS".
     If the parent and the nested structures have fields with same name, then that filed is not promoted.

Example:
    type details struct {  
        name   string 
        age    int
        gender string 
    } 
    
    // Nested structure 
    type student struct { 
        branch string //change branch -> name and observe the output. "name" field will not be promoted anyomore
        year   int
        details 
    } 
    
    func main() { 
    
        // Initializing the fields of 
        // the student structure 
        values := student{ 
            branch: "CSE", 
            year:   2010, 
            details: details{ 
            
                name:   "Sumit", 
                age:    28, 
                gender: "Male", 
            }, 
        } 
    
        // Promoted fields of the student structure 
        fmt.Println("Name: ", values.name) 
        fmt.Println("Age: ", values.age) 
        fmt.Println("Gender: ", values.gender) 
    
        // Normal fields of 
        // the student structure 
        fmt.Println("Year: ", values.year) 
        fmt.Println("Branch : ", values.branch) 
    } 
    
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++ FUNCTION AS A FIELD IN STRUCTURES  +++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Declaration: type function_name func()
             type strcut_name struct{
               var_name  function_name
             }

Example:

// Function
type Finalsalary func(int, int) int
  
// Creating structure 
type Author struct { 
    name      string 
    language  string 
    Marticles int
    Pay       int
  
    salary Finalsalary           // Defined function as a field
    getSalary func(int, int) int // Anonymous functions as a field
}

// Main method 
func main() { 
  
    // Initializing the fields 
    // of the structure 
    result := Author{ 
        name:      "Sonia", 
        language:  "Java", 
        Marticles: 120, 
        Pay:       500, 
        salary: func(Ma int, pay int) int { 
            return Ma * pay 
        }, 
        getSalary: func(Ma int, pay int) int {
            return Ma * pay
        }
    } 
  
    // Display values 
    fmt.Println("Author's Name: ", result.name) 
    fmt.Println("Language: ", result.language) 
    fmt.Println("Total number of articles published in May: ", result.Marticles) 
    fmt.Println("Per article pay: ", result.Pay) 
    fmt.Println("Total salary: ", result.salary(result.Marticles, result.Pay)) 
    fmt.Println("Total salary: ", result.getSalary(result.Marticles, result.Pay)) 
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++ PROMOTED METHODS AS FIELDS IN STRUCTURES+++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

READ ON IT


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++ *** ARRAYS AND SLICES *** +++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

+++++++++++++++++++++++++++++++++
+ ARRAYS: Sequential containers +
+++++++++++++++++++++++++++++++++

Declaration: 
    1-D Array: var arr_name [size]type or arr_name := [size]{item1, item2, ... item_n}
    Multi-dimentional Array: var arr_name [size_1][size_2]..[size_n]type

NOTES: If an array is not initialized, its default values are 0.
       To declare an array of unknown size, use: arr := [...]type.
       An array is of value type not of reference type. 
       Arrays can be compared using == operator.

COPYING AN ARRAY INTO ANOTHER ARRAY:
1. Making a copy: dest = src
2. Creating a reference: dest = &src
3. Using a loop:
    dest := make([]int, len(src))
    for index, value := range src {
        dest[index] = value
    }
4. Using copy method
    dest := make([]int, len(src))
    copy(dest, src)

+++++++++++++++++++++++++++++++++
++ SLICES: Similar to vectors  ++
+++++++++++++++++++++++++++++++++
Definition:
    1. A lightweight data structure
    2. A slice is a reference to a portion of an array by specifying the starting index and the length
       of the portion. 
    3. Internally, slice and an array are connected with each other, a slice is a reference to an 
       underlying array.
    4. A slice is of REFERENCE type.

Declaration:
    Declared similar to array but the size is not specified.
    slice := []type or []type{} or []type{item1, item2, ..., item_n}

Creating a slice:
    slice := arr[start_index, end_index] --> end_index is not included in the slice

Append elements to a slice:
    append(slice, 6,7,8) --> Appends all 3 elements to the slice.

Comparison:
    1. Use == operator to check if an array is nil or not.
    2. Equality operator throws an error while comparing 2 slices.
    3. To compare 2 slices, either use a for loop or use the DeeplyEqual() method.
    4. To compare 2 slices of bytes in go, use either of the below 2 methods:
        a. bytes.Equal(slice1, slice2): returns either true or false
        b. bytes.Compare(slice1, slice2): this method returns
            0: if the slices are equal
            1: if slice1 > slice2
            2: if slice2 > slice1

Copying of a slice:
    copy(dest, src)

Common operations:
    1. Add an element at end: slice := append(slice, item)
    2. Add an element at front: slice := append(item, slice...)
    3. Remove an element at an index: slice := append(slice[:index], slice[index+1:])
    4. Sorting a slice:
        sort.Strings(str_slice) //sorts a slice containing strings
        sort.Int(int_slice) // sorts a slice containing integer items
        IntsAreSorted(int_slice): checks if the integer slice is sorted or not.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++ *** STRINGS *** ++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++ *** POINTERS *** +++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++ *** INTERFACE *** ++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Definition: 
    1. Different from other languages
    2. Custom type and contains only method(not functions) signatures
    3. Cannot create instances of interfaces
    4. A variable of interface can be created which is later assigned with a concrete type value
       like struct which has the methods the interface requires.
    
    SYNTAX: type interface_name interface {
                //Method signatures
                func method1()
                func method2() string
            }

Example:
type Tank interface {
    Tarea() int
    Volume() float64
}

type TankDimensions struct {
    radius float64
    height float64
}

func(d TankDimensions) Tarea() int {
    return (int)(2*3.14*d.radius*d.radius)
}

func (d TankDimensions) Volume() float64 {
    return 3.14*d.radius*d.radius*d.height
}

func main() {
    tank Tank
    tank = TankDimensions(5, 10)

    fmt.Println("area: ", tank.Tarea())
    fmt.Println("volume: ", tank.Volume())
}

TYPE ASSERTION: A process to extract the value of an interface.
    SYNTAX: val, isPresent := interface_name.(type)
    
    Example:
        func myfun(a interface{}) {                 | func main() {
            val, ok := a.(string)                   |   var strInterface interface {
            if ok {                                 |   } = "this is a test"
                fmt.Println("Value: ", val)         |   
            } else {                                |   myfun(strInterface)
                fmt.Println("Value not present")    |  }
            }                                       |
        }                                           |

USAGE:
    1. When a method/function is required to pass different types of arguments like the Println().
    2. When multiple types use the same interface.

NOTE: No 2 interfaces can have methods with same name.

INTERFACE EMBEDDING: READ MORE ON IT
    1. An interface can embed other interfaces or an interface can embed other interface’s 
       method signatures in it.
    2. Any changes made in the methods of an interface, will be reflected in the embedded 
       interface also.

    Example:
    type interface_name1 interface {        |    | type interface_name1 interface {
        Method1()                           |    |      Method1()
    }                                       |    | }
                                            |    |
    type interface_name2 interface {        |    | type interface_name2 interface {
        Method2()                           | or |      Method2()
    }                                       |    |  }
                                            |    |
    type finalinterface_name interface {    |    | type finalinterface_name interface {
        interface_name1                     |    |      Method1()
        interface_name2                     |    |      Method22()
    }                                       |    | }

POLYMORPHISM: can be achieved using interface


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++ *** CONCURRENCY *** +++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

GOROUTINE:
    Definition:
        1. A function or method which executes independently and simultaneously in connection with other 
        Goroutines.
        2. Every concurrently executing activity is a Goroutine.

        SYNTAX: create a function and call it using go keyword.
        Example:
            func coroutine() {} //function Definition
            go coroutine() //execute the Goroutine

    Advantages of Goroutines:
    1. Cheaper(in time and space) than threads.
    2. Goroutine are stored in the stack and the size of the stack can grow and shrink according to the 
       requirement of the program. But in threads, the size of the stack is fixed
    3. Goroutines can communicate using the channel and these channels are specially designed to prevent 
       race conditions when accessing shared memory using Goroutines.
    4. If one of the Goroutines block the main thread(which has multiple Goroutine running parallely), due 
       to resource requirements, then all the other Goroutines will be assigned to a newly created OS thread.

    ANONYMOUS GOROUTINE:
    Syntax: go func(params_list) {
                //statements
            }(arguments)

SELECT STATEMENT:
    Definition:
        1. Similar to switch but has no parameter.
        2. The case statement refers to communication channel.

    SYNTAX:
        select{
            case SendOrReceive1:
                //statement
            case SendOrReceive2:
                //statement
            case SendOrReceive2:
                //statement
            default:
                //statement
        }

    NOTES:
        1. Select statement waits until the communication(send or receive operation) is prepared 
           for some cases to begin.
        2. If a select statement does not contain any case statement, then that select statement 
           waits forever.
        3. When the default statement is not present in the select statement, then it waits till
           one of the case statement is executed.
        4. The default statement protects select statement from blocking by executing itself when
           none of the case statements is ready for execution. 
        5. In select statement, if multiple cases are ready to proceed, then one of them can be 
           selected randomly.

Goroutine Vs Thrads:


++++++++++++++++++++++++++++++++++++++++++++ *** CHANNEL *** +++++++++++++++++++++++++++++++++++++++++++++++++
    Definition: 
        1. Medium of communication for Goroutines.
        2. The communication between Goroutines is lock-free.
        3. By default, a channel is bidirectional(send and receive data).
        4. In a channel, the send and receive operation block until the other side is ready by default. 
           This allows goroutine to synchronize with each other without explicit locks or condition variables.
    
    Declaration:
        1. var channel_name type
        2. channel_name := make(chan type)

    Send Operation in a channel:
        1. Non reference type values like int, float64, and bool are safe and easy to be sent through a 
           channel because they are copied. So there is no risk of accidental concurrent access of the 
           same value.
        2. Strings are safe to transfer because they are immutable.
        3. For sending pointers and reference type values like map, slices etc are not safe as they may 
           be changed by the sending/receiving goroutine at the same time producing unpredicted result.
           So, one must make sure that those values can only be accessed by one goroutine at a time.

    Closing a channel: close(channel_name)
    Check if a channel is open: result, ok := <- channel_name
    Length of a channel: len(channel_name), length is the number of items queued in the buffer.
    Capacity of a channel: cap(channel_name), capacity is the size of the buffer.

    NOTES:
        1. Blocking Send and Receive: When data sent to a channel, the control is blocked in that send 
           statement until other goroutine reads from that channel. Similarly, when a channel receives 
           data from a goroutine, the read statement blocks until another goroutine statement.
        2. Zero Value Channel: The zero value of the channel is nil.
        3. For loop in Channel: A for loop can iterate over the sequential values sent on the channel until 
           it closed.
           
           Example:
            for item := range Chnl { 
                // statements..
            }

UNIDIRECTIONAL CHANNELS:
    Definition: A channel that can either send or receive, but not both.

    Declaration:
        1. Channel to send data only: 
                channel_send := make(chan <- type)
        2. Channel to received data only: 
                channel_recv := make(<- chan bool)

    NOTE: 
        1. A bidirectional channel can be converted to a unidirectional channel.
        2. A unidirectional channel cannot be converted to a bidirectional channel.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++